--- a/portaudio/src/hostapi/wasapi/pa_win_wasapi.c
+++ b/portaudio/src/hostapi/wasapi/pa_win_wasapi.c
@@ -55,14 +55,15 @@

 // WASAPI
 #include <mmreg.h>  // must be before other Wasapi headers
-#if defined(_MSC_VER) && (_MSC_VER >= 1400)
+#if defined(_MSC_VER) && (_MSC_VER >= 1400)  || defined(__MINGW64_VERSION_MAJOR)
        #include <Avrt.h>
        #define COBJMACROS
-       #include <Audioclient.h>
+       #include <audioclient.h>
        #include <endpointvolume.h>
        #define INITGUID // Avoid additional linkage of static libs, excessive code will be optimized out by the compiler
-       #include <mmdeviceapi.h>
+       #include <functiondiscoverykeys_devpkey.h>
        #include <functiondiscoverykeys.h>
+       #include <mmdeviceapi.h>
     #include <devicetopology.h>        // Used to get IKsJackDescription interface
        #undef INITGUID
 #endif
@@ -83,7 +84,6 @@
 #include "pa_win_coinitialize.h"

 #if !defined(NTDDI_VERSION)
-
     #undef WINVER
     #undef _WIN32_WINNT
     #define WINVER       0x0600 // VISTA
@@ -413,6 +413,8 @@ typedef struct PaWasapiDeviceInfo

        // Formfactor
        EndpointFormFactor formFactor;
+       // Loopback indicator
+       int loopBack;
 }
 PaWasapiDeviceInfo;

@@ -1420,6 +1422,8 @@ PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiInd
     PaDeviceInfo *deviceInfoArray;
     HRESULT hr = S_OK;
        UINT i;
+    UINT renderCount;
+    UINT devIndex;
 #ifndef PA_WINRT
     IMMDeviceCollection* pEndPoints = NULL;
 #else
@@ -1524,6 +1528,19 @@ PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiInd
         }
     }

+    hr = IMMDeviceEnumerator_EnumAudioEndpoints(paWasapi->enumerator, eRender, DEVICE_STATE_ACTIVE, &pEndPoints);
+       // We need to set the result to a value otherwise we will return paNoError
+       // [IF_FAILED_JUMP(hResult, error);]
+       IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+
+    hr = IMMDeviceCollection_GetCount(pEndPoints, &renderCount);
+       // We need to set the result to a value otherwise we will return paNoError
+       // [IF_FAILED_JUMP(hResult, error);]
+       IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
+
+    SAFE_RELEASE(pEndPoints);
+    pEndPoints = NULL;
+
     hr = IMMDeviceEnumerator_EnumAudioEndpoints(paWasapi->enumerator, eAll, DEVICE_STATE_ACTIVE, &pEndPoints);
        // We need to set the result to a value otherwise we will return paNoError
        // [IF_FAILED_JUMP(hResult, error);]
@@ -1537,6 +1554,7 @@ PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiInd
 #else
        paWasapi->deviceCount = 2;
 #endif
+       paWasapi->deviceCount += renderCount;

     paWasapi->devInfo = (PaWasapiDeviceInfo *)PaUtil_AllocateMemory(sizeof(PaWasapiDeviceInfo) * paWasapi->deviceCount);
     if (paWasapi->devInfo == NULL)
@@ -1566,7 +1584,7 @@ PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiInd
             goto error;
         }

-        for (i = 0; i < paWasapi->deviceCount; ++i)
+        for (devIndex = 0, i = 0; i < paWasapi->deviceCount; ++i, ++devIndex)
                {
             PaDeviceInfo *deviceInfo  = &deviceInfoArray[i];
             deviceInfo->structVersion = 2;
@@ -1576,7 +1594,7 @@ PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiInd
                        PA_DEBUG(("WASAPI: ---------------\n"));

                #ifndef PA_WINRT
-            hr = IMMDeviceCollection_Item(pEndPoints, i, &paWasapi->devInfo[i].device);
+            hr = IMMDeviceCollection_Item(pEndPoints, devIndex, &paWasapi->devInfo[i].device);
                        // We need to set the result to a value otherwise we will return paNoError
                        // [IF_FAILED_JUMP(hResult, error);]
                        IF_FAILED_INTERNAL_ERROR_JUMP(hr, result, error);
@@ -1804,6 +1822,43 @@ PaError PaWasapi_Initialize( PaUtilHostApiRepresentation **hostApi, PaHostApiInd

             (*hostApi)->deviceInfos[i] = deviceInfo;
             ++(*hostApi)->info.deviceCount;
+
+                       if (paWasapi->devInfo[i].flow == eRender)
+                       {
+                char *deviceName;
+                UINT deviceNameLen;
+
+                memcpy(&deviceInfoArray[i + 1], deviceInfo, sizeof(*deviceInfo));
+                memcpy(&paWasapi->devInfo[i + 1], &paWasapi->devInfo[i], sizeof(*paWasapi->devInfo));
+
+                i++;
+                paWasapi->devInfo[i].loopBack = 1;
+
+                deviceInfo = &deviceInfoArray[i];
+
+                deviceInfo->maxInputChannels            = deviceInfo->maxOutputChannels;
+                deviceInfo->defaultHighInputLatency  = deviceInfo->defaultHighOutputLatency;
+                deviceInfo->defaultLowInputLatency   = deviceInfo->defaultLowOutputLatency;
+                deviceInfo->maxOutputChannels           = 0;
+                deviceInfo->defaultHighOutputLatency = 0;
+                deviceInfo->defaultLowOutputLatency  = 0;
+                               PA_DEBUG(("WASAPI:%d| def.SR[%d] max.CH[%d] latency{hi[%f] lo[%f]}\n", i, (UINT32)deviceInfo->defaultSampleRate,
+                                       deviceInfo->maxInputChannels, (float)deviceInfo->defaultHighInputLatency, (float)deviceInfo->defaultLowInputLatency));
+
+                IMMDevice_AddRef(paWasapi->devInfo[i].device);
+
+                deviceName = (char *)PaUtil_GroupAllocateMemory(paWasapi->allocations, MAX_STR_LEN + 1);
+                if (deviceName == NULL)
+                               {
+                    result = paInsufficientMemory;
+                    goto error;
+                }
+                               _snprintf(deviceName, MAX_STR_LEN-1, "%s (loopback)", deviceInfo->name);
+                deviceInfo->name = deviceName;
+
+                (*hostApi)->deviceInfos[i] = deviceInfo;
+                ++(*hostApi)->info.deviceCount;
+            }
         }
     }

@@ -2608,7 +2663,7 @@ static HRESULT CreateAudioClient(PaWasapiStream *pStream, PaWasapiSubStream *pSu
                }*/

                // select mixer
-               pSub->monoMixer = _GetMonoToStereoMixer(WaveToPaFormat(&pSub->wavex), (pInfo->flow == eRender ? MIX_DIR__1TO2 : MIX_DIR__2TO1_L));
+               pSub->monoMixer = _GetMonoToStereoMixer(WaveToPaFormat(&pSub->wavex), (output ? MIX_DIR__1TO2 : MIX_DIR__2TO1_L));
                if (pSub->monoMixer == NULL)
                {
                        (*pa_error) = paInvalidChannelCount;
@@ -2893,7 +2948,7 @@ static HRESULT CreateAudioClient(PaWasapiStream *pStream, PaWasapiSubStream *pSu
                        }*/

                        // Select mixer
-                       pSub->monoMixer = _GetMonoToStereoMixer(WaveToPaFormat(&pSub->wavex), (pInfo->flow == eRender ? MIX_DIR__1TO2 : MIX_DIR__2TO1_L));
+                       pSub->monoMixer = _GetMonoToStereoMixer(WaveToPaFormat(&pSub->wavex), (output ? MIX_DIR__1TO2 : MIX_DIR__2TO1_L));
                        if (pSub->monoMixer == NULL)
                        {
                                (*pa_error) = paInvalidChannelCount;
@@ -3209,7 +3264,8 @@ static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
                else
                if (fullDuplex)
                        stream->in.streamFlags = 0; // polling interface is implemented for full-duplex mode also
-
+               if (info->flow == eRender)
+                       stream->in.streamFlags |= AUDCLNT_STREAMFLAGS_LOOPBACK;
                // Fill parameters for Audio Client creation
                stream->in.params.device_info       = info;
                stream->in.params.stream_params     = (*inputParameters);

